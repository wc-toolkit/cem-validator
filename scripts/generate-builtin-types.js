/* eslint-disable no-undef */
import * as ts from 'typescript';
import fs from 'fs';
import path from 'path';

// Get the path to lib directory
const libDir = path.join(process.cwd(), 'node_modules', 'typescript', 'lib');
const libFiles = fs.readdirSync(libDir).filter(f => f.startsWith('lib.') && f.endsWith('.d.ts'));

// Collect types
const types = new Set();
const events = new Set();

// For each lib file
for (const libFile of libFiles) {
  const libPath = path.join(libDir, libFile);
  const libContent = fs.readFileSync(libPath, 'utf-8');
  const sourceFile = ts.createSourceFile(libFile, libContent, ts.ScriptTarget.ES2020, true);

  // Traverse the AST
  function visit(node) {
    if (ts.isTypeAliasDeclaration(node) || ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
      const name = node.name.text;
      types.add(name);
      if (name.endsWith('Event') || name === 'Event' || name === 'CustomEvent') {
        events.add(name);
      }
    }
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
}

// Also add some known types
const additionalTypes = [
  'string', 'number', 'boolean', 'bigint', 'symbol', 'undefined', 'null', 'any', 'unknown', 'never', 'void', 'array', 'Object', 'Array', 'Function', 'Date', 'RegExp', 'Map', 'Set', 'WeakMap', 'WeakSet', 'Promise', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'AggregateError', 'Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array', 'BigInt64Array', 'BigUint64Array', 'ArrayBuffer', 'SharedArrayBuffer', 'DataView', 'File', 'Blob', 'FormData', 'FileList', 'FileReader', 'Headers', 'Request', 'Response', 'URL', 'URLSearchParams', 'AbortController', 'AbortSignal', 'ReadableStream', 'WritableStream', 'TransformStream', 'WebSocket', 'SharedWorker', 'MessageChannel', 'MessagePort', 'Notification', 'BroadcastChannel', 'ImageData', 'ImageBitmap', 'TextEncoder', 'TextDecoder', 'Crypto', 'SubtleCrypto', 'Performance', 'PerformanceEntry', 'PerformanceObserver', 'IntersectionObserver', 'MutationObserver', 'ResizeObserver', 'Window', 'Document', 'Element', 'HTMLElement', 'ShadowRoot', 'Node', 'EventTarget', 'ScrollBehavior', 'FocusOptions', 'VirtualElement', 'Keyframe', 'KeyframeAnimationOptions', 'CSSNumberish', 'HTMLSlotElement', 'FillMode', 'PlaybackDirection', 'CustomStateSet', 'ElementInternals', 'EventInit'
];

additionalTypes.forEach(t => types.add(t));

// Sort
const nativeJsTypes = Array.from(types).sort();
const nativeEventTypes = Array.from(events).sort();

// Write to file
const output = `// Generated by scripts/generate-builtin-types.js
export const NATIVE_EVENT_TYPES = [
${nativeEventTypes.map(t => `  "${t}"`).join(',\n')},
] as const;

export const NATIVE_JS_TYPES = [
${nativeJsTypes.map(t => `  "${t}"`).join(',\n')},
] as const;

// Keywords and other non-exportable
const NON_EXPORTABLE_KEYWORDS = [
  "any",
  "unknown",
  "never",
  "void",
  "undefined",
  "null",
  "boolean",
  "number",
  "string",
  "bigint",
  "symbol",
  "object",
  "array",
  "readonly",
  "readonlyarray",
  "promise",
  "record",
  "partial",
  "required",
  "pick",
  "omit",
  "exclude",
  "extract",
  "nonnullable",
  "parameters",
  "returntype",
  "instancetype",
  "thistype",
  "keyof",
  "typeof",
  "in",
  "infer",
  "as",
  "extends",
  "templateresult",
  "function",
  "true",
  "false",
  "this",
  "internals"
];

export const NON_EXPORTABLE_TYPE_NAMES = new Set([
  ...NATIVE_JS_TYPES.map(t => t.toLowerCase()),
  ...NON_EXPORTABLE_KEYWORDS,
]);
`;

fs.writeFileSync(path.join(process.cwd(), 'src', 'generated-types.ts'), output);

console.log('Generated types written to src/generated-types.ts');